// Mock data for the portfolio website
export enum ProjectCategory {
  WEB_DEVELOPMENT = "Web Development",
  APP_DEVELOPMENT = "App Development", 
  GAME_DEVELOPMENT = "Game Development",
  FULL_STACK = "Full Stack"
}

export enum ButtonVariant {
  PRIMARY = "primary",
  SECONDARY = "secondary",
  OUTLINE = "outline"
}

export enum SectionType {
  HERO = "hero",
  PROJECTS = "projects",
  PROCESS = "process",
  DEMOS = "demos",
  NEWSLETTER = "newsletter",
  FOOTER = "footer"
}

// Data passed as props to the root component
export const mockRootProps = {
  projects: [
    {
      id: "supacrm",
      title: "SupaCRM",
      category: ProjectCategory.WEB_DEVELOPMENT as const,
      description: "A full-featured CRM for real estate agents â€” listing management, automated follow-ups, and analytics.",
      tech: ["React", "Firebase", "Tailwind"],
      image: "/images/supacrm.svg",
      liveUrl: "https://supacrm.vercel.app/",
      repoUrl: "https://github.com/KyPython/SupaCRM",
      featured: true
    },
    {
      id: "formflow",
      title: "FormFlow", 
      category: ProjectCategory.WEB_DEVELOPMENT as const,
      description: "SaaS for automating form workflows with secure hosting and CI/CD integration.",
      tech: ["React", "Node.js", "Express", "SCSS"],
      image: "/images/formflow.svg",
      liveUrl: "https://formflow-frontend-phi.vercel.app",
      repoUrl: "https://github.com/KyPython/FormFlow",
      featured: true
    },
      {
        id: "post-code-scraper",
        title: "Post Code Scraper",
        category: ProjectCategory.WEB_DEVELOPMENT as const,
    description: `This web application showcases my ability to build efficient and scalable solutions for data scraping and storage. The app scrapes postal codes from every state in the USA, and securely stores them in a Supabase database. It demonstrates my expertise in web scraping, database integration, and deploying production-ready applications.\n\nKey Features:\n- Automated Data Scraping: Efficiently extracts postal codes from targeted sources.\n- Secure Data Storage: Uses Supabase for reliable and scalable database management.\n- Cloud Deployment: Fully deployed on Render.com for seamless accessibility.\n\nWhy This Matters:\n- Build robust backend systems for data collection and storage.\n- Work with modern tools like Playwright, Supabase, and Render.\n- Deliver solutions that are ready for deployment in real-world scenarios.\n\nHow It Works:\n- Python: Core programming language for the scraper.\n- Playwright: For fast and reliable web scraping.\n- Supabase: A scalable backend-as-a-service for data storage.\n- Render: For cloud deployment and hosting.`,
    tech: ["Python", "Playwright", "Supabase", "Render", "Next.js", "TypeScript", "Tailwind CSS"],
        image: "/images/offline-tasks-pwa.png",
    liveUrl: "https://post-code-scraper.onrender.com",
  repoUrl: "https://github.com/KyPython/Post-Code-Scraper-New",
  featured: true,
  },
    {
      id: "algoclinic",
      title: "AlgoClinic",
      category: ProjectCategory.WEB_DEVELOPMENT as const,
      description: "Algorithm analysis platform with AI-driven insights, benchmarking and edge-case detection for developers and teams.",
      tech: ["React", "Python", "FastAPI", "Monaco Editor"],
      image: "/images/algoclinic.svg",
      liveUrl: "https://algo-clinic.vercel.app",
      repoUrl: "https://github.com/KyPython/AlgoClinic",
      featured: true
    },
    {
      id: "smartscan-ai",
      title: "SmartScan AI Frontend",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "Cross-platform client for AI-powered image captioning â€” real-time camera, async API and clean UX; deployed as an MVP.",
      tech: ["Expo Router", "React Native Web", "TypeScript"],
      image: "/images/smartscan-ai-frontend.svg",
      liveUrl: "https://smartscan-ai-frontend.vercel.app/onboarding",
      repoUrl: "https://github.com/KyPython/smartscan-ai-frontend",
      featured: true
    },
    {
      id: "growth-master",
    title: "Growth Master ðŸš€",
    category: ProjectCategory.APP_DEVELOPMENT as const,
    description: `A Clean, Emotionally-Driven Mobile App for Tracking Personal Growth & Performance\n\nGrowth Master is designed as a modern, intuitive mobile application focused on empowering users to track and celebrate their everyday progress. It's built on the principle that consistent small wins and positive micro-interactions lead to significant personal improvement. The app offers a seamless and emotionally resonant experience, helping users stay motivated by visualizing their journey towards better habits and faster performance.\n\nKey Features:\n- Daily Wins Tracking: Easily log and visualize small achievements and positive moments each day.\n- Personal Improvement Journey: Monitor progress across various personal goals and habits over time.\n- Fast Performance Insights: Track and analyze key performance metrics for rapid feedback and optimization.\n- Intuitive Micro-Interactions: Enjoy a smooth, responsive, and engaging user interface designed for effortless use.\n- Emotionally Driven Design: A clean and thoughtful design that fosters a positive and encouraging environment.\n\nFor freelance clients, Growth Master serves as a testament to expertise in developing user-centric, high-performance, and engaging mobile applications. This project showcases:\n- Front-End Proficiency: Expertise in creating clean, responsive, and aesthetically pleasing mobile interfaces using modern frameworks.\n- Emotionally Intelligent Design: The ability to translate abstract concepts like emotional drive and personal improvement into tangible, user-friendly features.\n- Data-Driven Tracking: Competence in designing systems for logging, analyzing, and presenting user data effectively.\n- Performance Optimization: A focus on delivering a fast and fluid user experience, critical for user retention.\n- Scalable Architecture: Understanding of how to structure an app for future growth and new features.\n\nChoosing a developer who can not only code but also deeply understand and translate user psychology into app design, as demonstrated by Growth Master, ensures a product that truly resonates with your target audience.`,
    tech: ["React Native", "HTML", "CSS/SCSS", "JavaScript", "TypeScript", "Git", "GitHub", "Figma"],
    image: "/images/growth-master.svg",
    liveUrl: "https://growth-master-green.vercel.app",
    repoUrl: "https://github.com/KyPython/Growth-Master",
    featured: true
    },
    {
      id: "streamengine",
      title: "StreamEngine",
      category: ProjectCategory.WEB_DEVELOPMENT as const,
      description: "Real-time data processing and visualization platform for live dashboards and scalable streaming infrastructure.",
      tech: ["React", "Node.js", "Kafka", "WebSockets"],
      image: "/images/streamengine.svg",
      liveUrl: "https://stream-engine-silk.vercel.app",
      repoUrl: "https://github.com/KyPython/StreamEngine",
      featured: true
    },
    {
      id: "reportengine",
      title: "ReportEngine",
      category: ProjectCategory.WEB_DEVELOPMENT as const,
      description: "Automated reporting and dashboards for business analytics; exports, scheduling and insights.",
      tech: ["Next.js", "Tailwind", "Vercel"],
      image: "/images/report-engine.svg",
      liveUrl: "https://reportengine.vercel.app/",
      repoUrl: "https://github.com/KyPython/ReportEngine",
      featured: false
    },
    {
      id: "salesbase-frontend",
      title: "SalesBase Frontend",
      category: ProjectCategory.WEB_DEVELOPMENT as const,
      description: "Modern CRM frontend with intuitive dashboards and realtime data integrations for enterprise sales teams.",
      tech: ["React", "Tailwind CSS"],
      image: "/images/salesbase-frontend.svg",
      liveUrl: "https://salesbase-frontend.vercel.app",
      repoUrl: "https://github.com/KyPython/SalesBase-Frontend",
      featured: false
    },
  {
    id: "altlens",
    title: "AltLens",
    category: ProjectCategory.APP_DEVELOPMENT as const,
    description: `AltLens is a React Native project created with Expo.\n\nGetting Started:\nTo run the project, use one of the following commands:\n- npm run android   # Run on Android emulator/device\n- npm run ios       # Run on iOS simulator/device\n- npm run web       # Run in the browser\n\nProject Structure:\n- App.js or App.tsx: Main entry point for the app\n- assets/: Images, fonts, and other static assets\n- components/: Reusable React Native components\n- screens/: App screens (if you add them)\n\nFirebase Integration Example:\nimport { auth, db } from '../lib/firebase';\n// Example: Sign up a user\n// import { createUserWithEmailAndPassword } from 'firebase/auth';\n// await createUserWithEmailAndPassword(auth, email, password);\n// Example: Add data to Firestore\n// import { collection, addDoc } from 'firebase/firestore';\n// await addDoc(collection(db, 'users'), { name: 'Jane Doe' });\n\nLearn More:\n- Expo Documentation: https://docs.expo.dev/\n- React Native Documentation: https://reactnative.dev/`,
    tech: ["React Native", "Expo", "Firebase", "JavaScript", "TypeScript"],
    image: "/images/project-placeholder.png",
    liveUrl: "https://alt-lens-app-new.vercel.app",
    repoUrl: "https://github.com/KyPython/Alt-Lens-App-New",
    featured: true,
  },
    {
      id: "skillsync",
      title: "SkillSync",
      category: ProjectCategory.FULL_STACK as const,
      description: "Full-stack microservices productivity application demonstrating multi-language backend development. Features task management (CRUD), goal tracking with progress bars, Pomodoro timer, motivational quotes API, and a real-time dashboard. Built with a microservices architecture using Java (Spring Boot), C# (.NET), Go (Gin), and Node.js (Express), all orchestrated through an API Gateway pattern and containerized with Docker.",
      tech: ["Java", "Spring Boot", "C#", ".NET", "Go", "Gin", "Node.js", "Express", "React", "TypeScript", "MongoDB", "Docker"],
      image: "/images/skillsync.png",
      liveUrl: "https://skillsync-snowy-phi.vercel.app/",
      repoUrl: "https://github.com/KyPython/skillsync",
      featured: true
    },
    {
      id: "offline-tasks-pwa",
      title: "Offline Tasks PWA",
      category: ProjectCategory.FULL_STACK as const,
      description: "A production-ready Progressive Web App (PWA) with offline-first architecture for task management. Features full CRUD operations that work seamlessly offline, automatic background synchronization when connectivity is restored, and native app-like experience with installable PWA capabilities. Built with modern web technologies and deployed across multiple cloud platforms.",
      tech: ["React", "Vite", "TypeScript", "Node.js", "Express", "Service Workers", "IndexedDB", "PWA", "Vercel", "Render"],
      image: "/images/offline-tasks-pwa.png",
      liveUrl: "https://offline-tasks-pwa.vercel.app/",
      repoUrl: "https://github.com/KyPython/offline-tasks-pwa",
      featured: true
    },
    {
      id: "offline-media-pwa",
      title: "Offline Media PWA",
      category: ProjectCategory.FULL_STACK as const,
      description: "A Progressive Web App (PWA) for creating and managing media submissions with offline-first architecture. Features photo and video uploads that work seamlessly offline, automatic background synchronization when connectivity is restored, and a sync queue to track pending uploads. Built with modern web technologies for reliable media management even in low-connectivity environments.",
      tech: ["React", "Vite", "TypeScript", "Node.js", "Express", "Service Workers", "IndexedDB", "PWA", "File API", "Vercel"],
      image: "/images/offline-media-pwa.png",
      liveUrl: "https://offline-media-pwa.vercel.app/",
      repoUrl: "https://github.com/KyPython/offline-media-pwa",
      featured: true
    },
    {
      id: "accessibleos",
      title: "AccessibleOS",
      category: ProjectCategory.FULL_STACK as const,
      description: "A comprehensive, accessible task management system built for Web, Mobile, and Unity platforms with strong accessibility foundations. Features WCAG 2.1 AA compliance, semantic HTML, ARIA roles, keyboard navigation, screen reader support, and multi-platform synchronization. Includes React web app, React Native mobile app, Unity game, and Node.js backend with PostgreSQL.",
      tech: ["React", "TypeScript", "React Native", "Node.js", "Express", "PostgreSQL", "Unity", "C#", "WCAG 2.1", "Accessibility"],
      image: "/images/accessibleos.png",
      liveUrl: "https://accessible-os-backend.vercel.app/",
      repoUrl: "https://github.com/KyPython/AccessibleOS",
      featured: true
    },
    {
      id: "cat-ate-my-source-code",
      title: "cat-ate-my-source-code",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A pragmatic backup & restore CLI tool for code projects, focused on disaster recovery and redundancy habits. Inspired by 'The Pragmatic Programmer', this tool helps developers develop good backup habits and protect code from disasters. Features versioned backups with timestamps, support for multiple projects, configurable exclude patterns, automatic retention policies, dry-run mode, and cross-platform compatibility. Designed with a config-driven approach for easy setup and management.",
      tech: ["TypeScript", "Node.js", "CLI", "File System API", "npm"],
      image: "/images/project-placeholder.png",
      liveUrl: "",
      repoUrl: "https://github.com/KyPython/cat-ate-my-source-code",
      featured: true
    },
    {
      id: "software-entropy",
      title: "Software Entropy",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A code-smell detection CLI tool that scans code repositories for common issues like long functions, large files, and TODO/FIXME density. Features a pluggable rule system for easy extension, multiple output formats (JSON and pretty console), configurable thresholds, and efficient scanning with customizable file patterns. Well-tested with comprehensive Jest test suite and designed for fast, actionable code quality insights.",
      tech: ["TypeScript", "Node.js", "CLI", "Jest", "Code Analysis", "AST"],
      image: "/images/project-placeholder.png",
      liveUrl: "",
      repoUrl: "https://github.com/KyPython/software-entropy",
      featured: true
    },
    {
      id: "stone-soup-board",
      title: "Stone Soup Board",
      category: ProjectCategory.FULL_STACK as const,
      description: "A minimal kanban board application designed for iterative contribution and collaborative improvement. Follows the 'Stone Soup' philosophyâ€”starting with a simple foundation that invites collaborative enhancement. Features three columns (Ideas, In Progress, Done), full CRUD operations for cards, and a clean, intuitive interface. Built with React and TypeScript frontend, Node.js and Express backend, with comprehensive testing.",
      tech: ["React", "TypeScript", "Node.js", "Express", "Jest", "Kanban", "Full Stack"],
      image: "/images/stone-soup-board.png",
      liveUrl: "https://stone-soup-board.vercel.app/",
      repoUrl: "https://github.com/KyPython/stone-soup-board",
      featured: true
    },
    {
      id: "good-enough-soup",
      title: "Good Enough Soup",
      category: ProjectCategory.FULL_STACK as const,
      description: "A minimal viable product (MVP) demonstrating the 'build a minimal viable product, then iterate' approach. A simple daily habit tracker and check-in app where users record 1-3 wins per day. Features daily entry creation with date and notes, and a view of recent entries. Built with React and TypeScript frontend, Node.js and Express backend, emphasizing simplicity and iterative development.",
      tech: ["React", "TypeScript", "Node.js", "Express", "MVP", "Habit Tracker", "Full Stack"],
      image: "/images/good-enough-soup.png",
      liveUrl: "https://good-enough-soup.vercel.app/",
      repoUrl: "https://github.com/KyPython/good-enough-soup",
      featured: true
    },
    {
      id: "communicate-app",
      title: "Communicate",
      category: ProjectCategory.FULL_STACK as const,
      description: "A minimal team communication web app demonstrating good communication patterns: channels, messages, and threaded replies. Features real-time updates via WebSocket, organized channel-based conversations, and threaded replies to keep discussions focused. Built with React and TypeScript frontend, Node.js and Express backend with Socket.IO for real-time communication. Inspired by communication principles from The Pragmatic Programmer.",
      tech: ["React", "TypeScript", "Node.js", "Express", "Socket.IO", "WebSocket", "Real-time", "Full Stack"],
      image: "/images/communicate-app.png",
      liveUrl: "https://communicate-app.vercel.app/",
      repoUrl: "https://github.com/KyPython/communicate-app",
      featured: true
    },
    {
      id: "dry-refactor-sample",
      title: "DRY Refactor Sample",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A code demonstration project showcasing the DRY (Don't Repeat Yourself) principle from The Pragmatic Programmer. Demonstrates refactoring duplicated order processing logic into a single source of truth. Includes before/after code comparisons, comprehensive tests verifying identical behavior, and clear documentation of the refactoring benefits. Built with TypeScript, focusing on maintainability, consistency, and code quality principles.",
      tech: ["TypeScript", "DRY Principle", "Refactoring", "Code Quality", "Testing"],
      image: "/images/project-placeholder.png",
      liveUrl: "",
      repoUrl: "https://github.com/KyPython/dry-refactor-sample",
      featured: true
    },
    {
      id: "orthogonal-editor",
      title: "Orthogonal Editor",
      category: ProjectCategory.WEB_DEVELOPMENT as const,
      description: "A minimal text editor demonstrating orthogonality and modular design through a plugin system. Features low coupling and high cohesion with plugins that operate independently. Includes built-in plugins for word count, search, and text transformation. Demonstrates separation of concerns, dependency inversion, and the open/closed principle. Built with React and TypeScript, showcasing extensible architecture where new plugins can be added without modifying core editor code.",
      tech: ["React", "TypeScript", "Vite", "Plugin Architecture", "Modular Design", "Orthogonality"],
      image: "/images/orthogonal-editor.png",
      liveUrl: "https://orthogonal-editor.vercel.app/",
      repoUrl: "https://github.com/KyPython/orthogonal-editor",
      featured: true
    },
    {
      id: "reversible-flags",
      title: "Reversible Flags",
      category: ProjectCategory.FULL_STACK as const,
      description: "A demo application demonstrating reversible feature flags for safe rollouts and rollbacks. Showcases the concept of reversibility from The Pragmatic Programmerâ€”the ability to easily undo changes when something goes wrong. Features flag management UI, real-time flag toggling, and flag-dependent API responses. Built with React and TypeScript frontend, Node.js and Express backend, enabling instant rollback without code deployment.",
      tech: ["React", "TypeScript", "Node.js", "Express", "Vite", "Feature Flags", "Full Stack"],
      image: "/images/reversible-flags.png",
      liveUrl: "https://reversible-flags.vercel.app/",
      repoUrl: "https://github.com/KyPython/reversible-flags",
      featured: true
    },
    {
      id: "tracer-bullets-app",
      title: "Tracer Bullets App",
      category: ProjectCategory.FULL_STACK as const,
      description: "A demonstration of the 'tracer bullets' approach from The Pragmatic Programmerâ€”building a minimal end-to-end implementation to validate architecture, integration points, and system design before full development. Tracer bullets provide immediate feedback on whether the architecture works, allowing for early course correction. This app showcases a working skeleton that demonstrates the full data flow from frontend to backend, validating the chosen technologies and integration patterns. Built with React and TypeScript frontend, Node.js and Express backend, demonstrating the principle of building working code that can be iteratively refined rather than building components in isolation.",
      tech: ["React", "TypeScript", "Node.js", "Express", "Tracer Bullets", "Full Stack", "Architecture Validation"],
      image: "/images/tracer-bullets-app.png",
      liveUrl: "https://tracer-bullets-app.vercel.app/",
      repoUrl: "https://github.com/KyPython/tracer-bullets-app",
      featured: true
    },
    {
      id: "log-filter-dsl",
      title: "Log Filter DSL",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A domain-specific language (DSL) for filtering log lines, inspired by 'Domain Languages' from The Pragmatic Programmer. Instead of writing complex filtering logic in a general-purpose language, this DSL lets users express filters in a natural, domain-specific way. Features a classic compiler architecture with lexer, parser, and evaluator. Supports JSON and Key=Value log formats, comparison operations (equals, contains), logical operators (AND, OR, NOT), and grouping with parentheses. Includes CLI tool for command-line usage and programmatic API for integration. Makes log filtering more readable, maintainable, and accessible to non-programmers.",
      tech: ["TypeScript", "Node.js", "CLI", "DSL", "Compiler", "Lexer", "Parser", "AST", "Domain Languages"],
      image: "/images/project-placeholder.png",
      liveUrl: "",
      repoUrl: "https://github.com/KyPython/log-filter-dsl",
      featured: true
    },
    {
      id: "estimate-tracker",
      title: "Estimate Tracker",
      category: ProjectCategory.FULL_STACK as const,
      description: "A full-stack web application for tracking time estimates versus actual time spent on tasks, helping developers improve their estimation accuracy over time. Inspired by the 'Estimating' chapter from The Pragmatic Programmer, which emphasizes learning from past estimates to improve future accuracy. Features task creation with estimated completion time, logging actual time spent, per-task statistics showing estimation accuracy, and aggregate statistics including average estimation error. Built with React and TypeScript frontend, Node.js and Express backend with SQLite database. Enables developers to identify patterns in estimation accuracy, learn which types of tasks they consistently over- or under-estimate, and improve future estimates based on historical data.",
      tech: ["React", "TypeScript", "Vite", "Node.js", "Express", "SQLite", "Full Stack", "Estimation"],
      image: "/images/estimate-tracker.png",
      liveUrl: "https://estimate-tracker-1nke5ujsq-kypythons-projects.vercel.app/",
      repoUrl: "https://github.com/KyPython/estimate-tracker",
      featured: true
    },
    {
      id: "plain-text-tools",
      title: "Plain Text Tools",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A collection of utilities and command-line tools for processing and manipulating plain text files. Provides practical text processing capabilities for developers working with plain text formats, supporting common operations like text transformation, filtering, formatting, and analysis. Built as modular CLI tools that can be used independently or composed together for complex text processing workflows. Demonstrates the power of simple, focused tools that do one thing well, following Unix philosophy principles from The Pragmatic Programmer.",
      tech: ["TypeScript", "Node.js", "CLI", "Text Processing", "File Utilities"],
      image: "/images/project-placeholder.png",
      liveUrl: "",
      repoUrl: "https://github.com/KyPython/plain-text-tools",
      featured: true
    },
    {
      id: "shell-games",
      title: "Shell Games Toolkit",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A collection of reusable shell scripts that automate common development tasks, demonstrating the 'Shell Games' principle from The Pragmatic Programmer. Includes project scaffolding scripts, environment verification tools, and deployment automation. Features three essential scripts: new-node-project.sh for scaffolding Node.js/TypeScript projects with sensible defaults, dev-env-check.sh for verifying required development tools, and simple-deploy.sh for simulating deployment workflows. Built with POSIX shell for maximum portability across macOS, Linux, and Windows (via WSL). Demonstrates DRY principles applied to development workflows, eliminating repetitive typing, ensuring consistency, catching issues early, and standardizing processes.",
      tech: ["Shell", "Bash", "POSIX", "CLI", "Automation", "DevOps", "Shell Scripts"],
      image: "/images/project-placeholder.png",
      liveUrl: "",
      repoUrl: "https://github.com/KyPython/shell-games",
      featured: true
    },
    {
      id: "power-editing",
      title: "Power Editing Configuration",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "VS Code and Cursor editor configuration for maximum productivity, implementing the 'Power Editing' philosophy from The Pragmatic Programmer. The goal is to make your editor an extension of your handâ€”so natural that you don't think about how to edit, only what to edit. Includes optimized settings, custom keybindings, productivity-focused snippets for JavaScript/TypeScript and Python, and recommended extensions. Features multi-cursor editing mastery, fast symbol navigation, automated refactoring tools, and code structure manipulation. Emphasizes editing at the speed of thought through mastery of tools, customization, automation, and muscle memory. Includes comprehensive cheat sheet and learning path for mastering the top 10 power editing commands.",
      tech: ["VS Code", "Cursor", "Editor Configuration", "Productivity", "Keybindings", "Snippets", "Power Editing"],
      image: "/images/project-placeholder.png",
      liveUrl: "",
      repoUrl: "https://github.com/KyPython/power-editing",
      featured: true
    },
    {
      id: "git-workflows-sample",
      title: "Git Workflows Sample",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A sample Node.js + TypeScript application demonstrating solid Git workflows and branching strategies from The Pragmatic Programmer's 'Source Code Control' principles. Implements a branching model with main (stable production code), develop (integration branch), and feature/* branches. Includes comprehensive documentation on Git commands, pull request workflows, code review processes, and branching strategies. Serves as a practical example for teams learning to structure their Git workflow effectively. Demonstrates how proper source code control enables collaboration, maintains code quality, and supports safe experimentation through branching.",
      tech: ["TypeScript", "Node.js", "Git", "GitHub", "CI/CD", "Branching Strategies", "Source Control"],
      image: "/images/project-placeholder.png",
      liveUrl: "",
      repoUrl: "https://github.com/KyPython/git-workflows-sample",
      featured: true
    },
    {
      id: "debugging-demo",
      title: "Debugging Demo",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A buggy Node.js/TypeScript todo manager application designed to teach systematic debugging techniques from The Pragmatic Programmer. Contains intentional bugs including off-by-one errors, inverted conditions, and logic mistakes. Includes comprehensive debugging log demonstrating systematic bug identification, hypothesis-driven debugging, test-driven verification, and understanding of common bug patterns. Features step-by-step walkthrough showing symptoms, hypotheses, investigation, root causes, fixes, and verification. Serves as hands-on exercise for learning debugging principles: don't panic, make it fail, read error messages, rubber duck debugging, and fix the cause not the symptom.",
      tech: ["TypeScript", "Node.js", "Jest", "Debugging", "Testing", "Education"],
      image: "/images/project-placeholder.png",
      liveUrl: "",
      repoUrl: "https://github.com/KyPython/debugging-demo",
      featured: true
    },
    {
      id: "code-generator-tool",
      title: "Code Generator Tool",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A CLI tool for generating boilerplate code from templates, implementing the 'Code Generators' principle from The Pragmatic Programmer. Eliminates repetitive boilerplate by generating common patterns like CRUD modules from reusable templates. Features template placeholders for dynamic code generation, overwrite protection for safety, and extensible template system. Supports generating complete modules (Controller, Service, Model) with consistent structure and conventions. Demonstrates DRY principles applied to code generation: don't write repetitive code, generate it instead. Includes customizable templates, force flag for CI/CD automation, and output directory specification. Reduces manual coding errors, maintains consistency across codebase, and saves time on common patterns.",
      tech: ["TypeScript", "Node.js", "CLI", "Code Generation", "Templates", "Boilerplate", "DRY"],
      image: "/images/project-placeholder.png",
      liveUrl: "",
      repoUrl: "https://github.com/KyPython/code-generator-tool",
      featured: true
    },
    {
      id: "assertive-programming",
      title: "Assertive Programming Demo",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A demonstration of Assertive Programming principles from The Pragmatic Programmer, showing how runtime assertions improve reliability and debuggability. Demonstrates fail-fast, fail-loud programming through runtime assertions that catch bad states early. Includes side-by-side comparison of code with and without assertions, showing how silent failures become explicit errors. Features payment domain examples demonstrating preconditions, postconditions, and invariants. Shows how assertions document assumptions, enforce invariants, prevent silent failures, and enable early bug detection. Includes assertion helper functions, comprehensive examples, and test suites. Demonstrates Tip 33 from The Pragmatic Programmer: 'If It Can't Happen, Use Assertions to Ensure That It Won't'.",
      tech: ["TypeScript", "Node.js", "Jest", "Assertions", "Defensive Programming", "Testing", "Education"],
      image: "/images/project-placeholder.png",
      liveUrl: "",
      repoUrl: "https://github.com/KyPython/assertive-programming",
      featured: true
    },
    {
      id: "design-by-contract-lib",
      title: "Design by Contract Library",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A lightweight TypeScript library for enforcing Design by Contract principles in Node.js applications, based on The Pragmatic Programmer. Provides contract enforcement through preconditions (caller's obligations) and postconditions (function's obligations). Features contract wrapper function for declarative contract definition, manual assertion helpers (precondition/require and ensure), custom ContractViolationError class, and full TypeScript type safety. Makes assumptions and guarantees explicit, leading to better error messages, clearer documentation, earlier bug detection, and improved code reliability. Published as npm package @kypython/design-by-contract. Includes comprehensive examples, test suites, and usage patterns for contract wrappers, manual assertions, and mixed approaches.",
      tech: ["TypeScript", "Node.js", "npm", "Design by Contract", "Defensive Programming", "Library", "NPM Package"],
      image: "/images/project-placeholder.png",
      liveUrl: "https://www.npmjs.com/package/@kypython/design-by-contract",
      repoUrl: "https://github.com/KyPython/design-by-contract-lib",
      featured: true
    },
    {
      id: "using-exceptions-demo",
      title: "Using Exceptions Demo",
      category: ProjectCategory.FULL_STACK as const,
      description: "A demonstration API showcasing proper exception handling patterns from The Pragmatic Programmer's 'Using Exceptions' principle. Implements a Node.js + TypeScript Express API for order processing with custom exception hierarchy (AppError, ValidationError, NotFoundError, SystemError), central error handling middleware, and proper error context. Demonstrates recoverable vs. fatal errors with appropriate handling strategies, operational vs. programming error distinction, and fail-fast principles for unrecoverable states. Features Express routes demonstrating exception usage, error boundary handling, consistent error response format, and comprehensive logging. Shows how to catch exceptions at boundaries, use exceptions for exceptional problems (not control flow), and finish what you start. Live API deployed on Vercel with health check and order management endpoints.",
      tech: ["TypeScript", "Node.js", "Express", "API", "Exception Handling", "Error Handling", "Full Stack", "Vercel"],
      image: "/images/project-placeholder.png",
      liveUrl: "https://using-exceptions-demo.vercel.app/",
      repoUrl: "https://github.com/KyPython/using-exceptions-demo",
      featured: true
    },
    {
      id: "dead-programs-logging",
      title: "Dead Programs Tell No Lies",
      category: ProjectCategory.FULL_STACK as const,
      description: "A Node.js + TypeScript demonstration of the reliability principle 'Dead Programs Tell No Lies' from The Pragmatic Programmer. Implements fail-fast error handling with structured JSON logging, global error handlers for uncaught exceptions and unhandled rejections, config validation at startup that exits on missing required environment variables, and Express HTTP API demonstrating fatal error scenarios. Shows how programs should fail immediately and loudly when encountering unrecoverable errors rather than continuing in a broken state. Features structured logging with levels (debug, info, warn, error, fatal), non-zero exit codes for process managers, and clear error messages with context. Demonstrates startup failure on invalid configuration, recoverable vs. fatal errors, and proper process termination on corruption detection. Live API deployed on Render.",
      tech: ["TypeScript", "Node.js", "Express", "API", "Error Handling", "Logging", "Fail Fast", "Full Stack", "Render"],
      image: "/images/project-placeholder.png",
      liveUrl: "https://dead-programs-logging.onrender.com",
      repoUrl: "https://github.com/KyPython/dead-programs-logging",
      featured: true
    },
    {
      id: "balancing-resources",
      title: "Balancing Resources Demo",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A demonstration of safe resource acquisition and release patterns, implementing the 'Balancing Resources' principle from The Pragmatic Programmer. Shows proper resource management using a `withResource` helper that ensures resources are always released in finally blocks, even when errors occur. Demonstrates good patterns (proper resource management) vs. bad patterns (resource leaks) using a simulated database connection pool. Features connection pool simulation that tracks available, active, and leaked connections, showing what happens when resources are properly managed vs. when they leak. Includes examples of common mistakes like missing finally blocks, forgetting to release resources, and early returns without cleanup. Demonstrates Tip 30 from The Pragmatic Programmer: always release resources in finally blocks, acquire resources in the same scope where they're released, and use helper functions to reduce boilerplate and ensure consistency.",
      tech: ["TypeScript", "Node.js", "Resource Management", "Memory Management", "Connection Pooling", "Error Handling"],
      image: "/images/project-placeholder.png",
      liveUrl: "",
      repoUrl: "https://github.com/KyPython/balancing-resources",
      featured: true
    },
    {
      id: "decoupling-law-of-demeter",
      title: "Decoupling & Law of Demeter",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A demonstration of decoupling principles and the Law of Demeter from The Pragmatic Programmer. Shows how to reduce coupling between modules and classes by following the Law of Demeter (Don't Talk to Strangers) - objects should only communicate with their immediate neighbors, not with objects accessed through other objects. Demonstrates good patterns (loosely coupled, minimal dependencies) vs. bad patterns (tightly coupled, chained method calls) with practical examples. Features interactive examples showing how to refactor tightly coupled code into loosely coupled designs, reducing dependencies and improving maintainability. Includes demonstrations of how decoupling makes code more testable, flexible, and easier to change. Shows how to apply the Law of Demeter to avoid deep object navigation chains and create better abstractions. Live interactive demo deployed on GitHub Pages.",
      tech: ["JavaScript", "HTML", "CSS", "Decoupling", "Law of Demeter", "Design Patterns", "Architecture"],
      image: "/images/project-placeholder.png",
      liveUrl: "https://kypython.github.io/decoupling-law-of-demeter/",
      repoUrl: "https://github.com/KyPython/decoupling-law-of-demeter",
      featured: true
    },
    {
      id: "metaprogramming-demo",
      title: "Metaprogramming Demo",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A Python demonstration of metaprogramming techniques from The Pragmatic Programmer, showcasing runtime code generation and reflection capabilities. Features auto-logging decorator that automatically logs function calls, arguments, and return values, dynamic model factory for generating classes at runtime with validation, metaclass support for advanced class creation with custom metaclasses, and runtime reflection for inspecting and modifying code structure dynamically. Demonstrates how to write code that writes code, reducing boilerplate and enabling powerful abstractions. Shows practical applications of metaprogramming including decorators, dynamic class generation, and runtime code modification. Uses only Python standard library with no external dependencies. Includes comprehensive examples and documentation. Live documentation deployed on GitHub Pages.",
      tech: ["Python", "Metaprogramming", "Decorators", "Metaclasses", "Runtime Code Generation", "Reflection"],
      image: "/images/project-placeholder.png",
      liveUrl: "https://kypython.github.io/metaprogramming-demo/",
      repoUrl: "https://github.com/KyPython/metaprogramming-demo",
      featured: true
    },
    {
      id: "temporal-coupling-demo",
      title: "Temporal Coupling Demo",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A demonstration of how event-driven architecture helps avoid temporal coupling in distributed systems, from The Pragmatic Programmer. Shows the difference between tightly coupled synchronous code (where components must execute in specific order) and decoupled event-driven architecture using publish/subscribe pattern. Features interactive web demo comparing bad example (temporal coupling) vs. good example (event-driven), in-process event bus implementation, producer/consumer pattern demonstration, and performance comparison showing ~800ms vs. ~1ms latency. Demonstrates how temporal coupling creates tight dependencies where slow downstream services block upstream processes, and how event-driven architecture decouples components in both time and space. Includes TypeScript implementation with event bus, event type definitions, and real-world applications for microservices, event sourcing, CQRS, and message queues. Live interactive demo deployed on GitHub Pages.",
      tech: ["TypeScript", "Node.js", "Event-Driven Architecture", "Publish-Subscribe", "Temporal Coupling", "Microservices"],
      image: "/images/project-placeholder.png",
      liveUrl: "https://kypython.github.io/temporal-coupling-demo/",
      repoUrl: "https://github.com/KyPython/temporal-coupling-demo",
      featured: true
    },
    {
      id: "mvc-demo-app",
      title: "MVC Demo Application",
      category: ProjectCategory.FULL_STACK as const,
      description: "A simple Todo application demonstrating the Model-View-Controller (MVC) architectural pattern with clear separation of concerns, implementing 'It's Just a View' principle from The Pragmatic Programmer. Shows how to separate Models (data structures, business rules, data persistence), Views (presentation and user interface), and Controllers (request handling and coordination). Demonstrates that views are replaceable - the same Model can be rendered as HTML, JSON, PDF, or mobile UI without changing business logic. Features Todo model with business rules, thin controllers that delegate to models, EJS templates for views, and clear architectural boundaries. Shows how separation allows each layer to evolve independently, enables testability, maintainability, and scalability. Includes comprehensive routing, CRUD operations, and deployment configuration. Live application deployed on Render.",
      tech: ["JavaScript", "Node.js", "Express", "EJS", "MVC", "Architecture", "Full Stack", "Render"],
      image: "/images/project-placeholder.png",
      liveUrl: "https://mvc-demo-app.onrender.com",
      repoUrl: "https://github.com/KyPython/mvc-demo-app",
      featured: true
    },
    {
      id: "blackboard-pattern-demo",
      title: "Blackboard Pattern Demo",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A demonstration of the Blackboard architectural pattern from The Pragmatic Programmer, where a central blackboard holds the current state of a problem and multiple independent experts collaborate by reading from and writing to the blackboard. Features text enrichment system with SpellCheckerExpert (spelling corrections), SentimentAnalyzerExpert (emotional tone analysis), and KeywordExtractorExpert (keyword extraction). Demonstrates how experts interact only through the blackboard with no direct communication, enabling orthogonality, reversibility, design by contract, and decoupling. Shows coordination loop where experts check if they can contribute, process, and write updates until the problem is solved. Includes web interface for interactive demonstration, real-time processing visualization, and step-by-step processing history. Demonstrates how the pattern is useful for problems with no deterministic solution algorithm, requiring multiple areas of expertise, and benefiting from incremental refinement. Live demo deployed on Vercel.",
      tech: ["TypeScript", "Node.js", "Blackboard Pattern", "Architecture", "Design Patterns", "Expert Systems", "Vercel"],
      image: "/images/blackboard-pattern-demo.png",
      liveUrl: "https://blackboard-pattern-demo.vercel.app/",
      repoUrl: "https://github.com/KyPython/blackboard-pattern-demo",
      featured: true
    },
    {
      id: "program-by-coincidence",
      title: "Programming by Coincidence Demo",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A demonstration of the difference between programming by coincidence and intentional programming from The Pragmatic Programmer. Shows before/after comparison of discount calculation code, highlighting issues with magic numbers, unclear variable names, hidden assumptions, lack of validation, and unclear intent. Demonstrates how coincidentally-working code appears to work but fails when requirements change, edge cases appear, or someone else needs to maintain it. Features refactored intentional code with named constants, explicit validation, clear variable names, documented business rules, and type safety. Includes comprehensive test suite for both versions, showing how intentional code is more maintainable, debuggable, and understandable. Demonstrates specific improvements: replacing magic numbers with named constants, adding explicit validation, using clear variable names, documenting business rules, and ensuring type safety. Shows why this matters for maintainability, debugging, onboarding, and confidence in edge case handling.",
      tech: ["TypeScript", "Node.js", "Jest", "Refactoring", "Code Quality", "Intentional Programming", "Education"],
      image: "/images/project-placeholder.png",
      liveUrl: "",
      repoUrl: "https://github.com/KyPython/program-by-coincidence",
      featured: true
    },
    {
      id: "algorithm-speed-demo",
      title: "Algorithm Speed Demo",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A demonstration of algorithm performance differences from The Pragmatic Programmer's 'Algorithm Speed' principle (Tip 50). Showcases how different algorithms solve the same problem with varying time complexities through comprehensive benchmarking. Features search algorithms (Linear Search O(n) vs Binary Search O(log n)) and sort algorithms (Bubble Sort O(nÂ²) vs Merge Sort O(n log n) vs Built-in Timsort). Demonstrates dramatic performance differences that compound with input size - for example, Binary Search can be 50,000x faster than Linear Search for 1 million elements. Includes benchmark runner with high-precision timing, CSV and JSON export for analysis, and visual comparison of Big-O complexity growth. Shows why algorithm choice matters and when to optimize. Demonstrates that understanding Big-O notation helps estimate algorithm performance before implementation. Includes practical examples showing O(1), O(log n), O(n), O(n log n), and O(nÂ²) complexities with real performance data.",
      tech: ["TypeScript", "Node.js", "Algorithms", "Big-O Notation", "Performance", "Benchmarking", "Computer Science"],
      image: "/images/project-placeholder.png",
      liveUrl: "",
      repoUrl: "https://github.com/KyPython/algorithm-speed-demo",
      featured: true
    },
    {
      id: "refactoring-legacy-module",
      title: "Refactoring Legacy Module",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A demonstration of refactoring legacy code from The Pragmatic Programmer, showing how to systematically improve code quality while maintaining functionality. Demonstrates step-by-step refactoring process for legacy modules with issues like tight coupling, unclear naming, magic numbers, and lack of tests. Features before/after comparison showing how to apply refactoring techniques safely, including extracting functions, renaming variables, removing duplication, and improving structure. Shows how to refactor incrementally with tests to ensure behavior is preserved. Demonstrates principles of refactoring: small, safe steps, test-driven refactoring, and continuous improvement. Includes comprehensive examples of common refactoring patterns and when to apply them. Live interactive documentation deployed on GitHub Pages showing the refactoring journey.",
      tech: ["JavaScript", "TypeScript", "Refactoring", "Legacy Code", "Code Quality", "Testing", "Education"],
      image: "/images/project-placeholder.png",
      liveUrl: "https://kypython.github.io/refactoring-legacy-module/",
      repoUrl: "https://github.com/KyPython/refactoring-legacy-module",
      featured: true
    },
    {
      id: "easy-to-test-code",
      title: "Easy to Test Code",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A demonstration of testable code design principles from The Pragmatic Programmer, showcasing a Notification Service built with testability as a first-class concern. Demonstrates dependency injection, pure functions, and interface-based design that make code easy to test, maintain, and reason about. Features before/after comparison showing how hard-coded dependencies (Date.now(), Math.random(), HTTP libraries) make code impossible to test vs. injected dependencies that enable full control in tests. Includes comprehensive test suite with fakes (FakeClock, FakeRandom, FakeHttpClient) instead of mocks, showing how to test time-dependent logic instantly, deterministic randomness for exact assertions, and isolated HTTP calls without network. Demonstrates interface segregation, pure functions for easier testing, and test doubles that actually implement contracts. Shows how designing with testability in mind from the start results in faster tests, more reliable tests, easier debugging, and better design through loose coupling and clear contracts.",
      tech: ["TypeScript", "Node.js", "Jest", "Dependency Injection", "Testing", "Testability", "Design Patterns"],
      image: "/images/project-placeholder.png",
      liveUrl: "",
      repoUrl: "https://github.com/KyPython/easy-to-test-code",
      featured: true
    },
    {
      id: "evil-wizards-demo",
      title: "Evil Wizards Demo",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A pedagogical demonstration contrasting obfuscated, unmaintainable code with clear, maintainable code from The Pragmatic Programmer. Both implementations have identical functionality and pass the same tests, but differ dramatically in readability, maintainability, and developer experience. Features side-by-side comparison showing the 'Evil Wizard's' code with cryptic variable names (x1, a, b, f, g), dense single-line complex logic, mixed responsibilities, and poor error handling vs. the 'Good Wizard's' code with descriptive names, small focused functions, proper documentation, and type safety. Demonstrates real-world impact: reading obfuscated code takes 10-20x longer, debugging becomes exponentially harder, and features take longer to add. Shows how code quality directly affects business costs: slower feature development, higher bug rates, increased onboarding time, and technical debt. Includes comprehensive test suite verifying both implementations produce identical results, proving that clarity doesn't require sacrificing correctness. Live interactive documentation on GitHub Pages showing the dramatic difference between obfuscated and clear code.",
      tech: ["TypeScript", "Node.js", "Jest", "Code Quality", "Readability", "Maintainability", "Education"],
      image: "/images/project-placeholder.png",
      liveUrl: "https://kypython.github.io/evil-wizards-demo/",
      repoUrl: "https://github.com/KyPython/evil-wizards-demo",
      featured: true
    },
    {
      id: "requirements-pit-tool",
      title: "Requirements Pit Tool",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A tool for capturing and structuring software requirements systematically, inspired by The Pragmatic Programmer's emphasis on clear requirements engineering. The 'Requirements Pit' metaphor represents the deep, structured approach needed to uncover, organize, and document requirements. Features structured templates for all requirement types including user personas (primary and secondary users with goals and pain points), functional requirements with acceptance criteria, non-functional requirements (performance, security, usability, reliability, maintainability), risks and assumptions, success criteria, and out-of-scope items. Enables systematic requirements gathering with export options to Markdown or JSON formats. Demonstrates best practices: starting with clear problem statements, understanding users to prioritize features, being specific to avoid misunderstandings, documenting assumptions to prevent project failures, identifying risks early for proactive mitigation, defining measurable success criteria, and setting clear boundaries to prevent scope creep. Live interactive tool deployed on Vercel for real-world requirements engineering.",
      tech: ["React", "TypeScript", "Vite", "Requirements Engineering", "Project Planning", "Documentation"],
      image: "/images/requirements-pit-tool.png",
      liveUrl: "https://requirements-pit-tool.vercel.app/",
      repoUrl: "https://github.com/KyPython/requirements-pit-tool",
      featured: true
    },
    {
      id: "solving-impossible-puzzles",
      title: "Solving Impossible Puzzles",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A case study in debugging a seemingly 'impossible' bugâ€”a subtle race condition in an async task queue that only appeared under concurrent load, demonstrating 'Solving Impossible Puzzles' from The Pragmatic Programmer. Features a buggy implementation and fixed implementation side-by-side, showing how a simple task queue system can have subtle race conditions causing tasks to execute multiple times, tasks to be skipped, and intermittent failures under high concurrency. The bug is non-obvious because the code looks correct at first glance, passes simple unit tests, only fails under concurrent load, and symptoms are intermittent. Includes comprehensive case study documenting the debugging journey: context of what made the bug seem impossible, observations and when they occurred, failed attempts and why they didn't work, hypotheses and experiments, the breakthrough moment, the fix, and lessons learned. Demonstrates key principles: Don't Panic, Read the Damn Error Message, Don't Assume It - Prove It, Find the Root Cause, Fix the Problem Not the Blame, and Select Isn't Broken. Shows how race conditions are real even in single-threaded JavaScript, why testing under load is essential, how check-then-act patterns are not atomic in async code, and how systematic debugging works. Live case study documentation on GitHub Pages.",
      tech: ["TypeScript", "Node.js", "Jest", "Debugging", "Race Conditions", "Async Programming", "Case Study"],
      image: "/images/project-placeholder.png",
      liveUrl: "https://kypython.github.io/solving-impossible-puzzles/",
      repoUrl: "https://github.com/KyPython/solving-impossible-puzzles",
      featured: true
    },
    {
      id: "readiness-checklist-tool",
      title: "Readiness Checklist Tool",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A web-based tool to evaluate whether a project is ready to start, helping teams identify gaps in planning, requirements, resources, and risk mitigation before beginning execution. Embodies the 'Not Until You're Ready' principle from The Pragmatic Programmer, emphasizing that it's better to delay a project start to address critical gaps than to rush into execution with unresolved issues. Features interactive assessment with 24 questions across 4 key categories: Requirements Clarity (assessing clarity and completeness of project requirements), Technical Feasibility (evaluating technical readiness and feasibility), Team & Resources (checking team availability and resource allocation), and Risks & Mitigations (identifying risks and assessing mitigation strategies). Provides visual scoring with 1-5 rating scale (Very Poor to Excellent), comprehensive analysis with category breakdowns, actionable recommendations for areas needing attention, and clear status indicators (Ready, Needs Clarification, or Not Ready). Demonstrates how systematic evaluation prevents premature project starts that lead to scope creep, technical debt, resource conflicts, unmanaged risks, and project failures. Live interactive tool deployed on Vercel for real-world project readiness assessment.",
      tech: ["React", "TypeScript", "Vite", "Project Planning", "Risk Assessment", "Requirements Engineering"],
      image: "/images/readiness-checklist-tool.png",
      liveUrl: "https://readiness-checklist-tool.vercel.app/",
      repoUrl: "https://github.com/KyPython/readiness-checklist-tool",
      featured: true
    },
    {
      id: "specification-trap-demo",
      title: "Specification Trap Demo",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A demonstration comparing over-specification vs. pragmatic, lightweight requirements for the same simple feature, illustrating 'The Specification Trap' from The Pragmatic Programmer. Shows how teams can fall into the trap of spending excessive time creating detailed specifications that become rigid, outdated, and hinder rather than help development. Features side-by-side comparison of two approaches for a simple todo application: Heavy Spec (16 sections, 50+ detailed requirements, formal approval process) vs. Light Spec (4 user stories with acceptance criteria). Includes a working React/TypeScript implementation built from the light spec, demonstrating that both approaches can work but the light spec approach gets you to working software faster. Demonstrates key problems with over-specification: false confidence, rigidity, delayed learning, outdated quickly, and compliance over value. Embodies multiple Pragmatic Programmer principles: DRY (light spec states each requirement once), Orthogonality (separates user needs from implementation), Tracer Bullets (enables building quickly to validate assumptions), Prototypes and Post-it Notes (builds faster for better understanding), Design by Contract (establishes minimal contracts), Pragmatic Paranoia (handles obvious cases and adapts), The Requirements Pit (acknowledges real requirements emerge through building), and Great Expectations (sets achievable expectations). Live interactive demo on GitHub Pages showing the working application and detailed analysis comparing both approaches.",
      tech: ["React", "TypeScript", "Vite", "Requirements Engineering", "User Stories", "Agile", "Education"],
      image: "/images/specification-trap-demo.png",
      liveUrl: "https://kypython.github.io/specification-trap-demo/",
      repoUrl: "https://github.com/KyPython/specification-trap-demo",
      featured: true
    },
    {
      id: "circles-and-arrows-design",
      title: "Circles and Arrows Design",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A system design repository demonstrating the 'Circles and Arrows' approach from The Pragmatic Programmer, emphasizing simple, clear diagrams over overly complex UML diagrams that become maintenance burdens. Features system design documentation using Mermaid diagrams (text-based, version-control friendly) to communicate system architecture and data relationships effectively without over-engineering. Includes architecture diagrams showing microservices-based systems with API gateway, services, databases, and external integrations, plus entity-relationship diagrams showing users, products, orders, payments, and their relationships. Demonstrates key principles: clarity over completeness (show what matters, not every detail), maintainability (diagrams should be easy to update as the system evolves), and communication (diagrams should help teams understand the system quickly). Shows why text-based diagrams are better: version control friendly (can be diffed, reviewed, and merged like code), low maintenance (simple diagrams are easier to keep up-to-date), accessible (works in many tools without special software), collaborative (team members can edit without proprietary tools), and documentation as code (diagrams live alongside code). Live documentation on GitHub Pages with interactive Mermaid diagrams showing architecture and data models for a sample e-commerce platform.",
      tech: ["Mermaid", "System Design", "Architecture", "Documentation", "Diagrams", "Software Engineering"],
      image: "/images/project-placeholder.png",
      liveUrl: "https://kypython.github.io/circles-and-arrows-design/",
      repoUrl: "https://github.com/KyPython/circles-and-arrows-design",
      featured: true
    },
    {
      id: "pragmatic-teams-workflow",
      title: "Pragmatic Teams Workflow",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A demonstration repository showcasing how a small, pragmatic team collaborates on a project using GitHub best practices, inspired by The Pragmatic Programmer's emphasis on effective team collaboration. Features a simple Todo app built with React and TypeScript, along with complete workflow documentation and examples. Demonstrates how to structure issues effectively (bug reports, feature requests, chores), write clear pull requests with templates, collaborate through code reviews, maintain clean project history, and document team processes. Includes realistic workflow simulation showing issue creation, development process with branching strategy, code review practices, and merge/deploy cycles. Embodies pragmatic teams philosophy: simplicity over complexity (simple branching, clear commit messages, focused PRs), communication over process (clear issue descriptions, helpful PR descriptions, constructive code reviews), velocity over perfection (ship working code, iterate based on feedback, don't over-engineer), and documentation as code (keep docs close to code, update docs with changes, make onboarding easy). Includes example issues, pull requests, contributing guidelines, and issues guide. Live interactive demo on GitHub Pages showing the Todo app and complete workflow documentation.",
      tech: ["React", "TypeScript", "Vite", "GitHub", "Workflow", "Team Collaboration", "Git"],
      image: "/images/pragmatic-teams-workflow.png",
      liveUrl: "https://kypython.github.io/pragmatic-teams-workflow/",
      repoUrl: "https://github.com/KyPython/pragmatic-teams-workflow",
      featured: true
    },
    {
      id: "ubiquitous-automation",
      title: "Ubiquitous Automation",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A demo showcasing CI/CD and DevOps automation principles from The Pragmatic Programmer's 'Ubiquitous Automation' concept, demonstrating how to automate routine development tasks and establish continuous integration practices. Features automation of testing (automated test execution), linting (code quality checks), building (compilation and artifact generation), and CI/CD (continuous integration via GitHub Actions). Includes local automation scripts (test-all.sh, lint-and-test.sh, pre-commit.sh) that eliminate manual command repetition, comprehensive GitHub Actions workflow that runs on every push and pull request, and demonstrates key principles: Don't Repeat Yourself (DRY) with centralized automation, automated testing at multiple levels (local, pre-commit, CI), fail fast with immediate error detection, and single command execution for complex workflows. Shows how to automate everything you can: building projects, running tests, generating documentation, and deploying applications. Demonstrates that the goal of ubiquitous automation isn't just to save timeâ€”it's to eliminate the possibility of human error in repetitive tasks. Live interactive demo on Vercel with API endpoints showcasing application features.",
      tech: ["TypeScript", "Node.js", "GitHub Actions", "CI/CD", "DevOps", "Automation", "Shell Scripts"],
      image: "/images/ubiquitous-automation.png",
      liveUrl: "https://ubiquitous-automation.vercel.app/",
      repoUrl: "https://github.com/KyPython/ubiquitous-automation",
      featured: true
    },
    {
      id: "ruthless-testing-demo",
      title: "Ruthless Testing Demo",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A demonstration of Ruthless Testing strategy with a multi-layer test suite for a Node.js + TypeScript HTTP API, implementing testing principles from The Pragmatic Programmer. Features a complete testing strategy with three distinct layers: Unit Tests (fast, isolated, testing pure functions and business logic), Integration Tests (medium speed, testing API routes with component integration), and System Tests (slowest, end-to-end testing of full application stack). Demonstrates the test pyramid approach: 70% unit tests (fast, many), 20% integration tests (medium speed, moderate number), 10% system tests (slow, few, critical paths only). Shows how to catch bugs early at the cheapest level, get fast feedback (unit tests run in milliseconds), enable continuous testing on every change, and build confidence for fearless refactoring and deployment. Includes comprehensive test suite for a Notes API with CRUD operations, demonstrating testing at the right level, comprehensive coverage of happy paths and edge cases, maintainable and readable tests, and how tests enable fearless refactoring. Live interactive demo on Vercel with API endpoints showcasing the testing strategy.",
      tech: ["TypeScript", "Node.js", "Express", "Jest", "Supertest", "Testing", "Test Pyramid", "CI/CD"],
      image: "/images/project-placeholder.png",
      liveUrl: "https://ruthless-testing-demo.vercel.app/",
      repoUrl: "https://github.com/KyPython/ruthless-testing-demo",
      featured: true
    },
    {
      id: "great-expectations-stakeholders",
      title: "Great Expectations Stakeholders",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A demo showcasing Great Expectations principle from The Pragmatic Programmer, demonstrating how to manage stakeholder expectations effectively in software projects. Features tools and techniques for setting realistic expectations, communicating project status clearly, and preventing scope creep through transparent communication. Demonstrates how to avoid the 'Great Expectations' trap where stakeholders expect more than can be delivered, leading to disappointment and project failure. Includes practical examples of expectation management, status reporting, and stakeholder communication strategies. Shows how to set clear boundaries, communicate constraints early, and build trust through honest, transparent updates. Demonstrates the importance of under-promising and over-delivering, managing scope changes, and maintaining realistic timelines. Live interactive demo on GitHub Pages showcasing stakeholder management principles and tools.",
      tech: ["HTML", "CSS", "JavaScript", "Stakeholder Management", "Project Management", "Communication"],
      image: "/images/project-placeholder.png",
      liveUrl: "https://kypython.github.io/great-expectations-stakeholders/",
      repoUrl: "https://github.com/KyPython/great-expectations-stakeholders",
      featured: true
    },
    {
      id: "its-all-writing-docs",
      title: "It's All Writing",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A simple counter application demonstrating that software is all writing, implementing the 'It's All Writing' principle from The Pragmatic Programmer. Features a minimal but complete React + TypeScript application that serves as a practical example of how every aspect of software developmentâ€”from code to tests to configurationâ€”is fundamentally an act of writing and communication. Demonstrates that software is not just code: it's requirements written to specify what we build, design documents written to explain how we build, code written to implement functionality, tests written to verify behavior, configuration written to instruct tools, and documentation written to guide users. Includes comprehensive documentation: REQS.md (requirements specification), DESIGN.md (architecture & design), TESTS.md (test plan & coverage), DEPLOYMENT.md (build & deployment guide), and README.md (overview). Shows that every line of code tells a story, every function is a paragraph, and every module is a chapter. Demonstrates key principles: code as writing (every function name, variable name, and comment communicates intent), tests as specifications (executable documentation), configuration as instructions (telling tools what to do), and documentation as communication (requirements, design, tests, deployment all serve specific communication purposes). Live interactive demo on GitHub Pages with a simple counter interface showcasing the principle that code is read far more often than it's written.",
      tech: ["React", "TypeScript", "Vite", "Vitest", "React Testing Library", "Documentation", "Writing"],
      image: "/images/its-all-writing-docs.png",
      liveUrl: "https://kypython.github.io/its-all-writing-docs/",
      repoUrl: "https://github.com/KyPython/its-all-writing-docs",
      featured: true
    },
    {
      id: "intro-llm-chatbot",
      title: "LLM Chat API",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A minimal LLM chat API built with Node.js, TypeScript, Express, and the official OpenAI SDK. Features a clean, production-ready API for integrating large language models into applications. Includes POST /chat endpoint for sending chat messages and receiving assistant replies with conversation history support, GET /health endpoint for health checks, comprehensive error handling with appropriate HTTP status codes, token usage tracking (prompt tokens, completion tokens, total tokens), support for system messages, user messages, and assistant messages in conversation history, CORS enabled for cross-origin requests, and environment variable configuration for API keys. Demonstrates modern API design patterns, TypeScript type safety, Express.js routing, OpenAI SDK integration, and proper error handling. Built as a foundation for building more complex AI-powered applications. Includes clear documentation, example curl requests, and deployment configuration for Vercel. Shows how to build a production-ready API that can be extended with authentication, rate limiting, and persistent storage. Live API deployed on Vercel with interactive documentation.",
      tech: ["Node.js", "TypeScript", "Express", "OpenAI SDK", "REST API", "AI/ML", "LLM"],
      image: "/images/project-placeholder.png",
      liveUrl: "https://intro-llm-chatbot.vercel.app/",
      repoUrl: "https://github.com/KyPython/intro-llm-chatbot",
      featured: true
    },
    {
      id: "prompt-playground",
      title: "Prompt Engineering Playground",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A Node.js API for testing different prompt engineering techniques with OpenAI models. Features multiple prompt modes: zero-shot (model performs task with only instructions), one-shot (single example before processing), few-shot (2-3 examples for richer context), and chain-of-thought (step-by-step reasoning process). Includes task-aware example generation that automatically creates relevant examples based on task type (sentiment analysis, trivia/questions, summarization, translation, or generic), OpenAI integration using chat completion API (defaults to gpt-4o-mini), request logging with unique request IDs for tracking, usage tracking with token information (prompt tokens, completion tokens, total tokens), comprehensive error handling with validation and API error management, and deployment configurations for Vercel, Railway, and Render. Demonstrates advanced prompt engineering techniques, API design patterns, TypeScript type safety, and production-ready error handling. Shows how different prompting strategies affect model performance and output quality. Includes detailed documentation with example curl commands for each prompt mode, health check endpoint, and structured logging. Built as a playground for experimenting with and comparing different prompt engineering approaches.",
      tech: ["Node.js", "TypeScript", "Express", "OpenAI SDK", "Prompt Engineering", "AI/ML", "REST API"],
      image: "/images/project-placeholder.png",
      liveUrl: "",
      repoUrl: "https://github.com/KyPython/prompt-playground",
      featured: true
    },
    {
      id: "advanced-prompting-reasoner",
      title: "Advanced Prompting Reasoner",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A multi-step reasoning API that uses chain-of-thought (CoT) and self-consistency techniques for solving math and logic problems. Features three reasoning strategies: Naive (direct single-call approach without explicit reasoning, fastest but may lack detailed reasoning), Chain-of-Thought (step-by-step reasoning before providing final answer, provides reasoning trace and often improves accuracy), and Self-Consistency (runs multiple CoT samples in parallel with higher temperature for diversity, extracts final answers from each sample and uses majority voting to determine consensus answer, best accuracy but slower due to multiple API calls). Includes POST /solve endpoint for solving math and logic problems with specified strategy, GET /health endpoint for health checks, comprehensive error handling with validation and API error management, structured logging with timestamp, strategy, and question tracking, and deployment configurations for Vercel, Railway, and Render. Demonstrates advanced reasoning techniques, parallel API call orchestration, consensus algorithms, and production-ready API design. Shows how different reasoning strategies affect accuracy and performance for complex problem-solving tasks. Includes detailed documentation with example curl commands for each strategy, JavaScript/TypeScript usage examples, and deployment guides. Built as a demonstration of advanced prompting techniques for improving LLM reasoning capabilities.",
      tech: ["Node.js", "TypeScript", "Express", "OpenAI SDK", "Chain-of-Thought", "Self-Consistency", "AI/ML", "Reasoning"],
      image: "/images/project-placeholder.png",
      liveUrl: "https://advanced-prompting-reasoner.vercel.app/",
      repoUrl: "https://github.com/KyPython/advanced-prompting-reasoner",
      featured: true
    },
    {
      id: "llm-finetuning-demo",
      title: "LLM Fine-tuning Demo",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A comprehensive demonstration of fine-tuning large language models (LLMs) for custom tasks and domain-specific applications. Features fine-tuning workflow demonstration showing the complete process from data preparation to model deployment, training data preparation and formatting for LLM fine-tuning, model training configuration and hyperparameter tuning, fine-tuned model evaluation and comparison with base models, deployment strategies for fine-tuned models, and best practices for fine-tuning LLMs. Demonstrates advanced AI/ML engineering skills including data preprocessing, model training, evaluation metrics, and production deployment. Shows how fine-tuning can improve model performance on specific tasks, domains, or use cases compared to base models. Includes detailed documentation with step-by-step guides, code examples, and deployment instructions. Built as an educational resource and demonstration of fine-tuning capabilities for custom AI applications.",
      tech: ["Python", "LLM", "Fine-tuning", "Machine Learning", "AI/ML", "Model Training", "OpenAI", "Hugging Face"],
      image: "/images/project-placeholder.png",
      liveUrl: "https://kypython.github.io/llm-finetuning-demo/",
      repoUrl: "https://github.com/KyPython/llm-finetuning-demo",
      featured: true
    },
    {
      id: "rag-node-ts",
      title: "RAG Node.js TypeScript Service",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A production-ready RAG (Retrieval-Augmented Generation) HTTP service built with Node.js, Express, TypeScript, LangChain, OpenAI, and Pinecone. Features document ingestion pipeline for parsing PDF and Markdown files, chunking text, and storing embeddings in Pinecone vector database, semantic search using vector similarity search to retrieve relevant passages, LLM answer generation using OpenAI with citation support to track which passages were used, structured JSON-formatted logging for observability, dual query modes supporting retrieval-only or full RAG answer generation, and comprehensive API endpoints for health checks and querying. Demonstrates production-ready AI/ML engineering including vector database integration, document processing pipelines, semantic search implementation, citation tracking, and structured logging. Shows how RAG systems can provide accurate, context-aware answers by combining retrieval with generation. Includes detailed documentation with API examples, deployment guides for Vercel, Railway, Render, and Docker, testing documentation, and environment configuration. Built as a production-ready service demonstrating enterprise-grade RAG implementation.",
      tech: ["Node.js", "TypeScript", "Express", "LangChain", "OpenAI", "Pinecone", "RAG", "Vector Database", "AI/ML"],
      image: "/images/project-placeholder.png",
      liveUrl: "",
      repoUrl: "https://github.com/KyPython/rag-node-ts",
      featured: true
    },
    {
      id: "llm-internals-report",
      title: "LLM Internals Report",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A comprehensive research and educational project exploring the internal mechanisms of large language models (LLMs). Features interactive Jupyter notebooks demonstrating core LLM concepts including toy attention mechanisms, detailed technical report documenting LLM internals, hands-on implementations of key algorithms and architectures, educational content explaining transformer architecture, attention mechanisms, and neural network fundamentals, and research-quality documentation with code examples and visualizations. Demonstrates deep understanding of LLM architecture, neural network internals, and machine learning fundamentals. Shows how LLMs work at a fundamental level through practical implementations and detailed explanations. Includes Jupyter notebooks for interactive learning, comprehensive documentation, and code examples that make complex concepts accessible. Built as an educational resource and research project for understanding LLM internals from the ground up.",
      tech: ["Python", "Jupyter", "Machine Learning", "LLM", "Neural Networks", "Transformers", "Attention Mechanisms", "AI/ML", "Research"],
      image: "/images/project-placeholder.png",
      liveUrl: "https://github.com/KyPython/llm-internals-report",
      repoUrl: "https://github.com/KyPython/llm-internals-report",
      featured: true
    },
    {
      id: "llm-future-trends",
      title: "LLM Future Trends",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A comprehensive research and analysis project exploring future trends and developments in large language models (LLMs). Features in-depth analysis of emerging LLM technologies, trends, and predictions, forward-looking insights into the evolution of AI and language models, research on next-generation architectures and capabilities, analysis of industry trends and market directions, and strategic perspectives on the future of LLM technology. Demonstrates deep understanding of AI/ML landscape, ability to analyze and predict technological trends, and strategic thinking about the future of AI. Shows how to research and synthesize information about emerging technologies, identify key trends and patterns, and communicate insights effectively. Includes comprehensive documentation, visualizations, and analysis of future LLM developments. Built as an educational resource and strategic analysis project for understanding where LLM technology is heading. Live interactive site on GitHub Pages showcasing future trends analysis.",
      tech: ["Research", "Analysis", "LLM", "AI/ML", "Future Trends", "Strategic Analysis", "Technology Forecasting"],
      image: "/images/project-placeholder.png",
      liveUrl: "https://kypython.github.io/llm-future-trends/",
      repoUrl: "https://github.com/KyPython/llm-future-trends",
      featured: true
    },
    {
      id: "tools-assistant",
      title: "Tools & Frameworks Assistant",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A modular CLI assistant built with LangChain TypeScript that answers questions by intelligently calling specialized tools. Features modular tool architecture where each tool is independently developed, tested, and maintained, intelligent tool selection using LangChain's agent framework to automatically select the right tool(s) for each query, three specialized tools including Calculator (safe math evaluator for arithmetic operations), Web Search Stub (demonstration stub that returns canned search results), and Document Retriever (searches an in-memory knowledge base using keyword matching). Demonstrates production-ready AI/ML engineering including LangChain agent orchestration, modular architecture design, intelligent tool routing, and API design patterns. Shows how to build extensible AI systems that can dynamically select and invoke appropriate tools based on user queries. Includes comprehensive documentation, API endpoints for programmatic access (GET and POST), deployment configurations for Vercel, and TypeScript type safety throughout. Built as both a CLI application and web API, demonstrating how to create AI assistants that can intelligently route queries to specialized tools. Live interactive web interface on Vercel with API endpoints for programmatic access.",
      tech: ["TypeScript", "LangChain", "Node.js", "AI/ML", "Agent Framework", "Tool Calling", "API", "CLI"],
      image: "/images/tools-assistant.png",
      liveUrl: "https://tools-assistant.vercel.app/",
      repoUrl: "https://github.com/KyPython/tools-assistant",
      featured: true
    },
    {
      id: "ethics-safety-toolkit",
      title: "Ethics & Safety Toolkit",
      category: ProjectCategory.APP_DEVELOPMENT as const,
      description: "A lightweight Express.js service that wraps LLM generation endpoints with safety checks, screening outputs for toxicity and bias, and providing a review interface for flagged content. Features safety screening middleware with keyword-based toxicity and bias detection, non-blocking design that flags issues without blocking responses, review system with export endpoint for reviewing flagged outputs, educational codebase with clear comments explaining limitations and production alternatives, POST /generate endpoint for generating content with safety checks, GET /review/export endpoint for exporting flagged items for review, and GET /health endpoint for health checks. Demonstrates production-ready AI/ML engineering including safety-first design, ethical AI implementation, content moderation patterns, and review workflow systems. Shows how to build responsible AI systems that screen for toxicity and bias while maintaining usability. Includes comprehensive documentation with notes on production-grade alternatives (Perspective API, OpenAI moderation, ML-based bias detection), deployment configurations for Vercel, Railway, and Render, and TypeScript type safety throughout. Built as an educational resource and demonstration of ethical AI practices, with clear guidance on upgrading to production-grade safety solutions. Live API deployed on Vercel with interactive endpoints.",
      tech: ["TypeScript", "Node.js", "Express", "AI/ML", "Safety", "Ethics", "Content Moderation", "API"],
      image: "/images/project-placeholder.png",
      liveUrl: "https://ethics-safety-toolkit.vercel.app/",
      repoUrl: "https://github.com/KyPython/ethics-safety-toolkit",
      featured: true
    },
  ],
  personalInfo: {
    name: "Ky Jahn Smith",
    email: "kyjahntsmith@gmail.com",
    linkedIn: "https://www.linkedin.com/in/kyjahn-smith-16487224b/",
    github: "https://github.com/KyPython",
    description: "Highly motivated and versatile aspiring AI/ML Engineer and UI/UX Developer with a strong foundation in programming and specialized expertise in machine learning (Computer Vision, Time Series Analysis, Deep Learning, Game AI, Reinforcement Learning). Proficient in UI/UX Design, CSS, and HTML, demonstrating a comprehensive understanding of both front-end development and human-centered design principles."
  },
  navigationLinks: [
    { label: "Home", href: "/" },
    { label: "Projects", href: "/projects" },
    { label: "Knowledge", href: "/knowledge" },
    { label: "About Me", href: "/about" },
    { label: "Contact", href: "/contact" }
  ]
};